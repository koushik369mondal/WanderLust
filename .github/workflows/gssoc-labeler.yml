name: "🚀 GSSoC'25 Auto-Labeler"

on:
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  auto-label-gssoc:
    name: "🏷️ Apply GSSoC'25 and Smart Level Labels"
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      issues: write
      pull-requests: write
      contents: read

    steps:
      - name: "🔄 Checkout Repository"
        uses: actions/checkout@v4

      - name: "🎯 Classify and Label Issue or PR"
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            console.log('🚀 GSSoC AUTO-LABELER v2.0 STARTED');
            console.log(`📅 Timestamp: ${new Date().toISOString()}`);
            console.log(`📋 Event: ${context.eventName} | Action: ${context.payload.action}`);

            // ============================================
            // LABEL DEFINITIONS
            // ============================================
            const REQUIRED_LABELS = [
              { name: 'gssoc', description: 'GirlScript Summer of Code 2025', color: 'ff6b35' },
              { name: 'level1', description: 'Beginner: 10 points - Good for newcomers', color: '28a745' },
              { name: 'level2', description: 'Intermediate: 25 points - Some experience needed', color: '0366d6' },
              { name: 'level3', description: 'Advanced: 45 points - Significant experience required', color: 'd73a49' },
              { name: 'good first issue', description: 'Good for newcomers', color: '7057ff' },
              { name: 'enhancement', description: 'New feature or request', color: 'a2eeef' },
              { name: 'bug', description: 'Something isn\'t working', color: 'd73a49' },
              { name: 'documentation', description: 'Documentation improvements', color: '0075ca' }
            ];

            // ============================================
            // UTILITY FUNCTIONS
            // ============================================

            /**
             * Ensure label exists, create if missing
             */
            async function ensureLabel(name, description, color) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name
                });
                console.log(`✓ Label exists: ${name}`);
              } catch (error) {
                if (error.status === 404) {
                  try {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name,
                      description,
                      color
                    });
                    console.log(`✅ Created label: ${name}`);
                  } catch (createError) {
                    console.error(`❌ Failed to create label ${name}:`, createError.message);
                  }
                }
              }
            }

            /**
             * Apply labels with retry mechanism
             */
            async function applyLabels(itemNumber, labels) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: itemNumber,
                  labels
                });
                console.log(`✅ Applied labels: ${labels.join(', ')}`);
                return true;
              } catch (error) {
                console.error(`❌ Failed to apply labels:`, error.message);
                return false;
              }
            }

            /**
             * Remove conflicting level labels
             */
            async function removeConflictingLabels(itemNumber, newLevel) {
              try {
                const { data: item } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: itemNumber
                });

                const levelLabels = ['level1', 'level2', 'level3'];
                const existingLevels = item.labels
                  .map(l => l.name.toLowerCase())
                  .filter(name => levelLabels.includes(name) && name !== newLevel.toLowerCase());

                for (const label of existingLevels) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: itemNumber,
                      name: label
                    });
                    console.log(`🗑️ Removed conflicting label: ${label}`);
                  } catch (e) {
                    console.warn(`⚠️ Could not remove ${label}:`, e.message);
                  }
                }
              } catch (error) {
                console.warn(`⚠️ Error removing conflicting labels:`, error.message);
              }
            }

            // ============================================
            // ISSUE CLASSIFICATION LOGIC
            // ============================================

            /**
             * Determine level for issues with anti-abuse measures
             */
            function classifyIssue(issue) {
              const title = (issue.title || '').toLowerCase();
              const body = (issue.body || '').toLowerCase();
              const content = title + ' ' + body;
              const bodyLength = body.length;

              let score = 0;

              console.log(`\n📊 ANALYZING ISSUE`);
              console.log(`📝 Title: "${issue.title}"`);
              console.log(`📏 Body length: ${bodyLength} chars`);

              // PENALTY: Very short descriptions
              if (bodyLength < 50) {
                score -= 25;
                console.log(`⚠️ Very short description penalty: -25`);
              } else if (bodyLength < 100) {
                score -= 15;
              } else if (bodyLength < 150) {
                score -= 5;
              }

              // PENALTY: Low-effort patterns
              const spamPatterns = [
                /^(bug|fix|error|issue|problem|help)$/i,
                /^(fix bug|fix error|fix issue|fix this)$/i,
                /^(please fix|need help|help me|broken)$/i
              ];

              if (spamPatterns.some(p => p.test(title.trim()))) {
                score -= 30;
                console.log(`⚠️ Low-effort title pattern: -30`);
              }

              // LEVEL 3: Advanced (45 points)
              const level3Keywords = [
                'security vulnerability', 'sql injection', 'xss', 'csrf', 'authentication bypass',
                'database migration', 'schema redesign', 'breaking change', 'data loss prevention',
                'memory leak', 'performance bottleneck', 'scalability', 'load balancing',
                'architecture refactor', 'microservices', 'system design',
                'ci/cd pipeline', 'kubernetes', 'docker swarm', 'deployment automation',
                'websocket', 'real-time sync', 'streaming data',
                'oauth2 implementation', 'jwt security', 'encryption'
              ];

              // LEVEL 2: Intermediate (25 points)
              const level2Keywords = [
                'new feature', 'feature request', 'enhancement', 'add functionality',
                'api endpoint', 'rest api', 'graphql', 'backend logic',
                'frontend component', 'react component', 'user interface',
                'authentication', 'authorization', 'user management',
                'form validation', 'data processing', 'algorithm',
                'search functionality', 'filter', 'pagination', 'sorting',
                'notification system', 'email service', 'sms integration',
                'file upload', 'image processing', 'media handling',
                'dashboard', 'analytics', 'reporting', 'chart',
                'responsive design', 'mobile view', 'accessibility'
              ];

              // LEVEL 1: Beginner (10 points)
              const level1Keywords = [
                'typo', 'spelling mistake', 'grammar', 'text change', 'wording',
                'documentation', 'readme', 'comment', 'docs update',
                'css styling', 'color change', 'font', 'margin', 'padding', 'alignment',
                'button style', 'icon', 'logo update', 'favicon',
                'broken link', 'dead link', 'url fix',
                'whitespace', 'formatting', 'indentation', 'prettier',
                'minor fix', 'small change', 'quick fix', 'simple update'
              ];

              // Count matches
              const l3Count = level3Keywords.filter(kw => content.includes(kw)).length;
              const l2Count = level2Keywords.filter(kw => content.includes(kw)).length;
              const l1Count = level1Keywords.filter(kw => content.includes(kw)).length;

              console.log(`🔍 Keywords - L3:${l3Count} | L2:${l2Count} | L1:${l1Count}`);

              // Scoring with strict requirements
              if (l3Count >= 2 && bodyLength > 250) {
                score += l3Count * 10;
              } else if (l3Count >= 1 && bodyLength > 150) {
                score += l3Count * 5;
              }

              if (l2Count >= 2 && bodyLength > 150) {
                score += l2Count * 5;
              } else if (l2Count >= 1) {
                score += l2Count * 3;
              }

              if (l1Count >= 1) {
                score += l1Count * 2;
              }

              // Content quality indicators
              const codeBlocks = (body.match(/```[\s\S]*?```/g) || []).length;
              const inlineCode = (body.match(/`[^`]+`/g) || []).length;
              const urls = (content.match(/https?:\/\/[^\s]+/g) || []).length;
              const filePaths = (content.match(/[\w/-]+\.(js|jsx|ts|tsx|css|html|json|yml|yaml|py|java|cpp)/g) || []).length;
              const hasSteps = /step\s+\d|1\.|2\.|3\./i.test(body);
              const hasExpected = /expected|should|supposed to/i.test(body);

              console.log(`💻 Code blocks: ${codeBlocks} | Inline code: ${inlineCode}`);
              console.log(`📁 Files mentioned: ${filePaths} | URLs: ${urls}`);
              console.log(`✅ Steps: ${hasSteps} | Expected behavior: ${hasExpected}`);

              // Reward quality content
              if (codeBlocks > 0) score += Math.min(codeBlocks * 5, 15);
              if (inlineCode > 2) score += Math.min(inlineCode, 10);
              if (filePaths > 0) score += Math.min(filePaths * 3, 12);
              if (hasSteps) score += 5;
              if (hasExpected) score += 3;

              // Length bonuses
              if (bodyLength > 500) score += 10;
              else if (bodyLength > 300) score += 6;
              else if (bodyLength > 200) score += 3;

              // PENALTY: Generic bug words without context
              const genericWords = ['bug', 'error', 'broken', 'not working', "doesn't work"];
              const genericCount = genericWords.filter(w => content.includes(w)).length;
              if (genericCount >= 2 && bodyLength < 200 && codeBlocks === 0) {
                score -= 15;
                console.log(`⚠️ Generic terms without context: -15`);
              }

              // PENALTY: Question without details
              if (/\?/.test(title) && /how|what|why|where|when|can you|should i/i.test(content) && bodyLength < 100) {
                score -= 10;
                console.log(`❓ Vague question: -10`);
              }

              console.log(`📊 FINAL SCORE: ${score}`);

              // Classification thresholds
              if (score >= 50) return 'level3';
              if (score >= 20) return 'level2';
              return 'level1';
            }

            // ============================================
            // PR CLASSIFICATION LOGIC
            // ============================================

            /**
             * Determine level for PRs based on files changed
             */
            function classifyPR(files, prData) {
              const filesChanged = files.length;
              const additions = files.reduce((sum, f) => sum + f.additions, 0);
              const deletions = files.reduce((sum, f) => sum + f.deletions, 0);
              const totalChanges = additions + deletions;

              const title = (prData.title || '').toLowerCase();
              const body = (prData.body || '').toLowerCase();
              const content = title + ' ' + body;

              let score = 0;

              console.log(`\n📊 ANALYZING PR`);
              console.log(`📝 Title: "${prData.title}"`);
              console.log(`📁 Files: ${filesChanged} | Changes: +${additions}/-${deletions} = ${totalChanges}`);

              // File-type analysis
              for (const file of files) {
                const path = file.filename.toLowerCase();
                const changes = file.additions + file.deletions;

                // Critical files
                if (/^(app|server|index|main)\.(js|ts|py)$/.test(path)) {
                  score += 20;
                } else if (/^(schema|database|config)\.(js|ts|py)$/.test(path)) {
                  score += 15;
                } else if (/package(-lock)?\.json|yarn\.lock|requirements\.txt|pom\.xml/.test(path)) {
                  score += 10;

                // Backend
                } else if (/^(models?|controllers?|routes?|api|services?|middleware)\/.*\.(js|ts|py|java)$/.test(path)) {
                  score += 8 + Math.min(changes / 20, 6);

                // Security/Auth
                } else if (/(auth|security|passport|jwt).*\.(js|ts|py)$/.test(path)) {
                  score += 12;

                // Database
                } else if (/^(migrations?|seeds?|db)\/.*(\.js|\.ts|\.sql|\.py)$/.test(path)) {
                  score += 10;

                // Frontend
                } else if (/\.(jsx?|tsx?|vue|svelte)$/.test(path) && !/test/.test(path)) {
                  score += 4 + Math.min(changes / 30, 4);
                } else if (/\.(css|scss|sass|less)$/.test(path)) {
                  score += 2 + Math.min(changes / 50, 3);
                } else if (/\.(html|ejs|hbs|pug|blade\.php)$/.test(path)) {
                  score += 3 + Math.min(changes / 40, 3);

                // Tests
                } else if (/(test|spec|__tests__|\.test\.|\.spec\.)/.test(path)) {
                  score += 6;

                // CI/CD
                } else if (/\.github\/workflows\/.*\.ya?ml$/.test(path)) {
                  score += 8;
                } else if (/docker|dockerfile|docker-compose/i.test(path)) {
                  score += 9;

                // Docs
                } else if (/\.(md|txt|rst|adoc)$/.test(path)) {
                  score += 1;
                } else if (/\.(png|jpe?g|gif|svg|ico|webp|pdf)$/.test(path)) {
                  score += 0.5;

                // Other
                } else {
                  score += 2;
                }
              }

              // Volume scoring
              if (filesChanged > 25) score += 20;
              else if (filesChanged > 15) score += 15;
              else if (filesChanged > 8) score += 10;
              else if (filesChanged > 4) score += 5;

              if (totalChanges > 2000) score += 18;
              else if (totalChanges > 1000) score += 12;
              else if (totalChanges > 500) score += 8;
              else if (totalChanges > 200) score += 4;

              // PR description analysis
              const l3PrKeywords = ['breaking change', 'major refactor', 'security fix', 'vulnerability', 'critical', 'hotfix', 'architecture'];
              const l2PrKeywords = ['feature', 'enhancement', 'add', 'implement', 'integration', 'component'];
              const l1PrKeywords = ['docs', 'documentation', 'typo', 'readme', 'style', 'format', 'minor'];

              if (l3PrKeywords.some(kw => content.includes(kw))) score += 12;
              if (l2PrKeywords.some(kw => content.includes(kw))) score += 5;
              if (l1PrKeywords.some(kw => content.includes(kw))) score -= 8;

              // File diversity bonus
              const extensions = new Set(files.map(f => f.filename.split('.').pop()));
              if (extensions.size > 5) score += 6;
              else if (extensions.size > 3) score += 3;

              console.log(`📊 FINAL SCORE: ${score}`);

              // Classification thresholds
              if (score >= 60) return 'level3';
              if (score >= 25) return 'level2';
              return 'level1';
            }

            // ============================================
            // CONTEXTUAL LABELING
            // ============================================

            /**
             * Get additional labels based on content
             */
            function getContextualLabels(item, level) {
              const labels = [];
              const title = (item.title || '').toLowerCase();
              const body = (item.body || '').toLowerCase();
              const text = title + ' ' + body;

              // Good first issue
              if (level === 'level1') {
                labels.push('good first issue');
              }

              // Priority: Documentation > Bug > Enhancement
              // Documentation detection (highest priority for Level1)
              if (/documentation|docs|readme|comment|typo|spelling|grammar/i.test(text)) {
                labels.push('documentation');
              }
              // Bug detection (prioritize over enhancement)
              else if (/bug|error|crash|broken|fail|not working|doesn't work|defect/i.test(text)) {
                labels.push('bug');
              }
              // Enhancement detection
              else if (/feature|enhancement|improve|add|new|implement|support for|request|would be nice/i.test(text)) {
                labels.push('enhancement');
              }
              // Fallback: check for "fix" which could be either
              else if (/\bfix\b/i.test(text)) {
                // If "fix" is mentioned with feature/add keywords, it's enhancement
                if (/feature|add|new|implement/i.test(text)) {
                  labels.push('enhancement');
                } else {
                  // Otherwise assume it's a bug fix
                  labels.push('bug');
                }
              }

              console.log(`🏷️ Contextual labels: ${labels.join(', ') || 'none'}`);
              return labels;
            }

            // ============================================
            // MAIN EXECUTION
            // ============================================

            try {
              // Ensure all labels exist
              console.log('\n🔧 Ensuring labels exist...');
              for (const label of REQUIRED_LABELS) {
                await ensureLabel(label.name, label.description, label.color);
              }

              let level, itemNumber, itemData;

              // Process Issue
              if (context.eventName === 'issues') {
                itemNumber = context.payload.issue.number;
                itemData = context.payload.issue;
                console.log(`\n📋 Processing Issue #${itemNumber}`);

                level = classifyIssue(itemData);
                const contextLabels = getContextualLabels(itemData, level);
                const allLabels = ['gssoc', level, ...contextLabels];

                await removeConflictingLabels(itemNumber, level);
                await applyLabels(itemNumber, allLabels);

                console.log(`\n✅ Issue #${itemNumber} labeled as ${level.toUpperCase()}`);
              }

              // Process PR
              else if (context.eventName === 'pull_request') {
                itemNumber = context.payload.pull_request.number;
                itemData = context.payload.pull_request;
                console.log(`\n🔀 Processing PR #${itemNumber}`);

                try {
                  const { data: files } = await github.rest.pulls.listFiles({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: itemNumber,
                    per_page: 100
                  });

                  if (files.length === 0) {
                    console.warn('⚠️ No files found, using default level2');
                    level = 'level2';
                  } else {
                    level = classifyPR(files, itemData);
                  }

                  const contextLabels = getContextualLabels(itemData, level);
                  const allLabels = ['gssoc', level, ...contextLabels];

                  await removeConflictingLabels(itemNumber, level);
                  await applyLabels(itemNumber, allLabels);

                  console.log(`\n✅ PR #${itemNumber} labeled as ${level.toUpperCase()}`);

                } catch (error) {
                  console.error(`❌ Error analyzing PR:`, error.message);
                  level = 'level2';
                  
                  // Try to get contextual labels even in fallback mode
                  const contextLabels = getContextualLabels(itemData, level);
                  const allLabels = ['gssoc', level, ...contextLabels];
                  
                  await removeConflictingLabels(itemNumber, level);
                  await applyLabels(itemNumber, allLabels);
                  console.log(`⚠️ Applied fallback labels to PR #${itemNumber}: ${allLabels.join(', ')}`);
                }
              }

              // Final verification
              console.log('\n🔍 Final verification...');
              const { data: finalItem } = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: itemNumber
              });

              const finalLabels = finalItem.labels.map(l => l.name);
              console.log(`📋 Final labels: ${finalLabels.join(', ')}`);
              console.log(`✓ Has gssoc: ${finalLabels.includes('gssoc')}`);
              console.log(`✓ Has level: ${finalLabels.some(l => l.startsWith('level'))}`);

              console.log('\n🎉 Auto-labeler completed successfully!');

            } catch (error) {
              console.error('❌ CRITICAL ERROR:', error.message);
              console.error('Stack trace:', error.stack);
              throw new Error(`Auto-labeler failed: ${error.message}`);
            }
